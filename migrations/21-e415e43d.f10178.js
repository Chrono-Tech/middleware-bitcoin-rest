
module.exports.id = '21.e415e43d.f10178';

const _ = require('lodash'),
  config = require('../config');

/**
 * @description flow e415e43d.f10178 update
 * @param done
 */
   

module.exports.up = function (done) {
  let coll = this.db.collection(`${_.get(config, 'nodered.mongo.collectionPrefix', '')}noderedstorages`);
  coll.update({"path":"e415e43d.f10178","type":"flows"}, {
    $set: {"path":"e415e43d.f10178","body":[{"id":"b68ffffb.8e49e","type":"catch","z":"e415e43d.f10178","name":"","scope":null,"x":240,"y":560,"wires":[["49075d44.432d44"]]},{"id":"5c2fd91f.e496a8","type":"http response","z":"e415e43d.f10178","name":"","statusCode":"","x":697,"y":561,"wires":[]},{"id":"49075d44.432d44","type":"function","z":"e415e43d.f10178","name":"transform","func":"\nlet factories = global.get(\"factories\"); \nlet error = msg.error.message;\ntry {\n    error = JSON.parse(error);\n}catch(e){}\n\nmsg.payload = error && error.code === 11000 ? \nfactories.messages.address.existAddress :\n\nmsg.error.message && msg.error.code ?\nmsg.error :\nfactories.messages.generic.fail;\n   \nreturn msg;","outputs":1,"noerr":0,"x":481,"y":560,"wires":[["5c2fd91f.e496a8"]]},{"id":"c1ff735e.f6bd1","type":"http in","z":"e415e43d.f10178","name":"send","url":"/tx/send","method":"post","upload":false,"swaggerDoc":"","x":250,"y":280,"wires":[["a83f15e5.fc4b28"]]},{"id":"a83f15e5.fc4b28","type":"async-function","z":"e415e43d.f10178","name":"","func":"const _ = global.get('_');\nconst genericMessages = global.get('factories').messages.generic;\nconst txMessages = global.get('factories').messages.tx;\n\nconst rpc = global.get('rpc');\n\n\n  if (!msg.payload.tx) {\n     throw new Error(genericMessages.notEnoughArgs);\n  }\n\n  let tx = await rpc('decoderawtransaction', [msg.payload.tx]);\n\n  let voutAddresses = _.chain(tx.vout)\n    .map(vout => _.get(vout, 'scriptPubKey.addresses', []))\n    .flattenDeep()\n    .uniq()\n    .value();\n\n  let inputs = await Promise.mapSeries(tx.vin, async vin => {\n    let tx = await rpc('getrawtransaction', [vin.txid, true]);\n    return tx.vout[vin.vout];\n  }).catch(() => Promise.reject(txMessages.wrongTx));\n\n  let vinAddresses = _.chain(inputs)\n    .map(vout => _.get(vout, 'scriptPubKey.addresses', []))\n    .flattenDeep()\n    .uniq()\n    .value();\n\n  let addresses = _.chain(voutAddresses)\n    .union(vinAddresses)\n    .flattenDeep()\n    .uniq()\n    .value();\n\n  tx.inputs = inputs;\n  tx.outputs = tx.vout.map(v => ({\n    value: Math.floor(v.value * Math.pow(10, 8)),\n    scriptPubKey: v.scriptPubKey,\n    addresses: v.scriptPubKey.addresses\n  }));\n\n  for (let i = 0; i < tx.inputs.length; i++) {\n    tx.inputs[i] = {\n      addresses: tx.inputs[i].scriptPubKey.addresses,\n      prev_hash: tx.vin[i].txid, //eslint-disable-line\n      script: tx.inputs[i].scriptPubKey,\n      value: Math.floor(tx.inputs[i].value * Math.pow(10, 8)),\n      output_index: tx.vin[i].vout //eslint-disable-line\n    };\n  }\n\n  tx.valueIn = _.chain(tx.inputs)\n    .map(i => i.value)\n    .sum()\n    .value();\n\n  tx.valueOut = _.chain(tx.outputs)\n    .map(i => i.value)\n    .sum()\n    .value();\n\n  tx.fee = tx.valueIn - tx.valueOut;\n  tx = _.omit(tx, ['vin', 'vout', 'blockhash']);\n\n  let hash = await rpc('sendrawtransaction', [msg.payload.tx]);\n  let memTxs = await rpc('getrawmempool', [true]);\n\n  tx.time = _.get(memTxs, `${hash}.time`, 0);\n  \n  msg.payload = tx;\n  return msg;\n  ","outputs":1,"noerr":12,"x":490,"y":280,"wires":[["c95e3eeb.97f9d"]]},{"id":"c95e3eeb.97f9d","type":"http response","z":"e415e43d.f10178","name":"","statusCode":"","x":790,"y":280,"wires":[]},{"id":"9758d2b4.28879","type":"http in","z":"e415e43d.f10178","name":"history","url":"/tx/:addr/history","method":"get","upload":false,"swaggerDoc":"","x":170,"y":380,"wires":[["ca42ccf2.cc3ff"]]},{"id":"ca42ccf2.cc3ff","type":"function","z":"e415e43d.f10178","name":"prepare request","func":"const prefix = global.get('settings.mongo.collectionPrefix');\nconst _ = global.get('_');\n\nmsg.address = msg.req.params.addr;\n\n\nmsg.payload ={ \n    model: `${prefix}TxAddressRelation`, \n    request: {\n      address: msg.address\n  },\n  options: {\n      sort: {blockNumber: -1},\n      limit: parseInt(msg.req.query.limit) || 100,\n      skip: parseInt(msg.req.query.skip) || 0\n  }\n};\n\nreturn msg;","outputs":1,"noerr":0,"x":340,"y":380,"wires":[["e6aea25e.ce0d9"]]},{"id":"e6aea25e.ce0d9","type":"mongo","z":"e415e43d.f10178","model":"","request":"{}","options":"{}","name":"mongo","mode":"1","requestType":"0","dbAlias":"primary.data","x":530,"y":380,"wires":[["bcfa0a27.cb3308"]]},{"id":"86a9e0c2.636de","type":"http response","z":"e415e43d.f10178","name":"","statusCode":"","x":1550,"y":380,"wires":[]},{"id":"bcfa0a27.cb3308","type":"function","z":"e415e43d.f10178","name":"prepare txs request","func":"const prefix = global.get('settings.mongo.collectionPrefix');\nconst _ = global.get('_');\n\nmsg.address = msg.req.params.addr;\n\nconst relations = msg.payload;\n\nmsg.payload =[\n{ \n    model: `${prefix}Tx`, \n    request: {\n      $or: relations.map(relation=>({\n          blockNumber: relation.blockNumber,\n          index: relation.txIndex\n      }))\n  }\n},\n\n{ \n    model: `${prefix}Coin`, \n    request: {\n      $or: _.chain(relations).map(relation=>\n    [\n      {\n        inputBlock: relation.blockNumber,\n        inputTxIndex: relation.txIndex\n      },\n      {\n        outputBlock: relation.blockNumber,\n        outputTxIndex: relation.txIndex\n      }\n    ]\n    )\n    .flattenDeep()\n    .value()\n  }\n}\n\n\n];\n\nreturn msg;","outputs":1,"noerr":0,"x":730,"y":380,"wires":[["7d843c05.8e4314"]]},{"id":"7d843c05.8e4314","type":"split","z":"e415e43d.f10178","name":"","splt":"\\n","spltType":"str","arraySplt":1,"arraySpltType":"len","stream":false,"addname":"","x":930,"y":380,"wires":[["b15576e1.7f9808"]]},{"id":"b15576e1.7f9808","type":"mongo","z":"e415e43d.f10178","model":"","request":"{}","options":"{}","name":"mongo","mode":"1","requestType":"0","dbAlias":"primary.data","x":1090,"y":380,"wires":[["f008bb44.bea2b8"]]},{"id":"f008bb44.bea2b8","type":"join","z":"e415e43d.f10178","name":"join ","mode":"auto","build":"string","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"","x":1210,"y":380,"wires":[["55773ce3.fa5be4"]]},{"id":"55773ce3.fa5be4","type":"function","z":"e415e43d.f10178","name":"prepare response","func":"const _ = global.get('_');\n\n\nlet txs =  _.get(msg.payload, '0.0.index') ? msg.payload[0] : msg.payload[1];\n\nif(!txs || !txs.length){\n    msg.payload = [];\n    return msg;\n}\n\n\nconst coins = _.get(msg.payload, '0.0.index') ? _.get(msg.payload, '1', []) : _.get(msg.payload, '0', []);\n\n\nmsg.payload = txs.map(tx=>{\n    \n    tx.inputs = _.chain(coins)\n      .filter({inputBlock: tx.blockNumber, inputTxIndex: tx.index})\n      .orderBy('inputIndex')\n      .map(coin => ({\n        address: coin.address,\n        value: coin.value\n      }))\n      .value();\n\n    tx.outputs = _.chain(coins)\n      .filter({outputBlock: tx.blockNumber, outputTxIndex: tx.index})\n      .map(coin => ({\n        address: coin.address,\n        value: coin.value\n      }))\n      .value();\n\n    return  tx;\n    \n});\n\n\n\nreturn msg;","outputs":1,"noerr":0,"x":1390,"y":380,"wires":[["86a9e0c2.636de"]]}]}
  }, {upsert: true}, done);
};

module.exports.down = function (done) {
  let coll = this.db.collection(`${_.get(config, 'nodered.mongo.collectionPrefix', '')}noderedstorages`);
  coll.remove({"path":"e415e43d.f10178","type":"flows"}, done);
};
